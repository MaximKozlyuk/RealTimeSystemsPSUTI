#include <stdio.h> 
#include <signal.h> 
#include <unistd.h> 
#include <sys/mman.h>
#include <native/task.h> 
#include <native/timer.h>

RT_TASK demo_task;
RT_TASK the_task2;

void demo(void *arg) {
	RTIME now, previous;
	rt_task_set_periodic(NULL, TM_NOW, 500000000); 
	previous = rt_timer_read();
	while (1) { 
		//Wait for the next periodic release point.
		//Make the current task wait for the next periodic release point in the processor time line.
		rt_task_wait_period(NULL); 
		now = rt_timer_read();
		printf(
			"Time since last turn: %ld.%06ld ms\n",
			(long)(now - previous) / 1000000, 
			(long)(now - previous) % 1000000
		); 
		previous = now;
	} 
}

void task2(void *arg) {
	RTIME now, previous;
	rt_task_set_periodic(NULL, TM_NOW, 2000000000); 
	previous = rt_timer_read();
	while (1) {
		//Wait for the next periodic release point.
		//Make the current task wait for the next periodic release point in the processor time line.
		rt_task_wait_period(NULL);
		now = rt_timer_read();
        printf("Bulychev and Kozlyuk\n");
		printf(
			"Time since last turn: %ld.%06ld ms\n",
			(long)(now - previous) / 1000000, 
			(long)(now - previous) % 1000000
		);
		previous = now;
	} 
}

void catch_signal(int sig) {

}

int main(int argc, char* argv[]) {
	// SIGTERM - (Signal Terminate) Termination request sent to program.
	signal(SIGTERM, catch_signal); 
	// SIGINT - (Signal Interrupt) Interactive attention signal. 
	//Generally generated by the application user.
	signal(SIGINT, catch_signal);

	// MCL_CURRENT - Lock all pages which are currently mapped into the address space of the process.
	// MCL_FUTURE - Lock all pages which will become mapped into the address space of the process 
	// in the future. These could be for instance new pages required by a growing heap and 
	// stack as well as new memory mapped files or shared memory regions.
	mlockall(MCL_CURRENT|MCL_FUTURE);

    rt_task_create(&the_task2, "the_second_task", 0, 99, 0);
    rt_task_start(&the_task2, &task2, NULL);

	rt_task_create(&demo_task, "trivial", 0, 5, 0);
	rt_task_start(&demo_task, &demo, NULL);

	pause();

	rt_task_delete(&demo_task); 
	rt_task_delete(&the_task2);
}
